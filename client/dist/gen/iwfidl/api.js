"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Workflow APIs
 * This APIs for iwf SDKs to operate workflows
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultApi = exports.DefaultApiFactory = exports.DefaultApiFp = exports.DefaultApiAxiosParamCreator = exports.WorkflowStopType = exports.WorkflowStatus = exports.WorkflowResetType = exports.WorkflowIDReusePolicy = exports.WorkflowErrorType = exports.WaitUntilApiFailurePolicy = exports.TimerStatus = exports.StartApiFailurePolicy = exports.SearchAttributeValueType = exports.PersistenceLoadingType = exports.IDReusePolicy = exports.ErrorSubStatus = exports.DeciderTriggerType = exports.CommandWaitingType = exports.CommandCarryOverType = exports.ChannelRequestStatus = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 *
 * @export
 * @enum {string}
 */
exports.ChannelRequestStatus = {
    Waiting: 'WAITING',
    Received: 'RECEIVED'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.CommandCarryOverType = {
    None: 'NONE'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.CommandWaitingType = {
    AllCompleted: 'ALL_COMPLETED',
    AnyCompleted: 'ANY_COMPLETED',
    AnyCombinationCompleted: 'ANY_COMBINATION_COMPLETED'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.DeciderTriggerType = {
    AllCommandCompleted: 'ALL_COMMAND_COMPLETED',
    AnyCommandCompleted: 'ANY_COMMAND_COMPLETED',
    AnyCommandCombinationCompleted: 'ANY_COMMAND_COMBINATION_COMPLETED'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ErrorSubStatus = {
    UncategorizedSubStatus: 'UNCATEGORIZED_SUB_STATUS',
    WorkflowAlreadyStartedSubStatus: 'WORKFLOW_ALREADY_STARTED_SUB_STATUS',
    WorkflowNotExistsSubStatus: 'WORKFLOW_NOT_EXISTS_SUB_STATUS',
    WorkerApiError: 'WORKER_API_ERROR'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.IDReusePolicy = {
    AllowIfPreviousExistsAbnormally: 'ALLOW_IF_PREVIOUS_EXISTS_ABNORMALLY',
    AllowIfNoRunning: 'ALLOW_IF_NO_RUNNING',
    DisallowReuse: 'DISALLOW_REUSE',
    AllowTerminateIfRunning: 'ALLOW_TERMINATE_IF_RUNNING'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.PersistenceLoadingType = {
    AllWithoutLocking: 'LOAD_ALL_WITHOUT_LOCKING',
    PartialWithoutLocking: 'LOAD_PARTIAL_WITHOUT_LOCKING',
    PartialWithExclusiveLock: 'LOAD_PARTIAL_WITH_EXCLUSIVE_LOCK'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.SearchAttributeValueType = {
    Keyword: 'KEYWORD',
    Text: 'TEXT',
    Datetime: 'DATETIME',
    Int: 'INT',
    Double: 'DOUBLE',
    Bool: 'BOOL',
    KeywordArray: 'KEYWORD_ARRAY'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.StartApiFailurePolicy = {
    FailWorkflowOnStartApiFailure: 'FAIL_WORKFLOW_ON_START_API_FAILURE',
    ProceedToDecideOnStartApiFailure: 'PROCEED_TO_DECIDE_ON_START_API_FAILURE'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.TimerStatus = {
    Scheduled: 'SCHEDULED',
    Fired: 'FIRED'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.WaitUntilApiFailurePolicy = {
    FailWorkflowOnFailure: 'FAIL_WORKFLOW_ON_FAILURE',
    ProceedOnFailure: 'PROCEED_ON_FAILURE'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.WorkflowErrorType = {
    StateDecisionFailingWorkflowErrorType: 'STATE_DECISION_FAILING_WORKFLOW_ERROR_TYPE',
    ClientApiFailingWorkflowErrorType: 'CLIENT_API_FAILING_WORKFLOW_ERROR_TYPE',
    StateApiFailMaxOutRetryErrorType: 'STATE_API_FAIL_MAX_OUT_RETRY_ERROR_TYPE',
    InvalidUserWorkflowCodeErrorType: 'INVALID_USER_WORKFLOW_CODE_ERROR_TYPE',
    ServerInternalErrorType: 'SERVER_INTERNAL_ERROR_TYPE'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.WorkflowIDReusePolicy = {
    AllowDuplicateFailedOnly: 'ALLOW_DUPLICATE_FAILED_ONLY',
    AllowDuplicate: 'ALLOW_DUPLICATE',
    RejectDuplicate: 'REJECT_DUPLICATE',
    TerminateIfRunning: 'TERMINATE_IF_RUNNING'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.WorkflowResetType = {
    HistoryEventId: 'HISTORY_EVENT_ID',
    Beginning: 'BEGINNING',
    HistoryEventTime: 'HISTORY_EVENT_TIME',
    StateId: 'STATE_ID',
    StateExecutionId: 'STATE_EXECUTION_ID'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.WorkflowStatus = {
    Running: 'RUNNING',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Timeout: 'TIMEOUT',
    Terminated: 'TERMINATED',
    Canceled: 'CANCELED',
    ContinuedAsNew: 'CONTINUED_AS_NEW'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.WorkflowStopType = {
    Cancel: 'CANCEL',
    Terminate: 'TERMINATE',
    Fail: 'FAIL'
};
/**
 * DefaultApi - axios parameter creator
 * @export
 */
const DefaultApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary update the config of a workflow
         * @param {WorkflowConfigUpdateRequest} [workflowConfigUpdateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowConfigUpdatePost: async (workflowConfigUpdateRequest, options = {}) => {
            const localVarPath = `/api/v1/workflow/config/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowConfigUpdateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary get workflow data objects
         * @param {WorkflowGetDataObjectsRequest} [workflowGetDataObjectsRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowDataobjectsGetPost: async (workflowGetDataObjectsRequest, options = {}) => {
            const localVarPath = `/api/v1/workflow/dataobjects/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowGetDataObjectsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary get a workflow\'s status and results(if completed & requested)
         * @param {WorkflowGetRequest} [workflowGetRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowGetPost: async (workflowGetRequest, options = {}) => {
            const localVarPath = `/api/v1/workflow/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowGetRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary get a workflow\'s status and results(if completed & requested), wait if the workflow is still running
         * @param {WorkflowGetRequest} [workflowGetRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowGetWithWaitPost: async (workflowGetRequest, options = {}) => {
            const localVarPath = `/api/v1/workflow/getWithWait`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowGetRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary dump internal info of a workflow
         * @param {WorkflowDumpRequest} [workflowDumpRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowInternalDumpPost: async (workflowDumpRequest, options = {}) => {
            const localVarPath = `/api/v1/workflow/internal/dump`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowDumpRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary reset a workflow
         * @param {WorkflowResetRequest} [workflowResetRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowResetPost: async (workflowResetRequest, options = {}) => {
            const localVarPath = `/api/v1/workflow/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowResetRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary execute an RPC of a workflow
         * @param {WorkflowRpcRequest} [workflowRpcRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowRpcPost: async (workflowRpcRequest, options = {}) => {
            const localVarPath = `/api/v1/workflow/rpc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowRpcRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary search for workflows by a search attribute query
         * @param {WorkflowSearchRequest} [workflowSearchRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowSearchPost: async (workflowSearchRequest, options = {}) => {
            const localVarPath = `/api/v1/workflow/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowSearchRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary get workflow search attributes
         * @param {WorkflowGetSearchAttributesRequest} [workflowGetSearchAttributesRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowSearchattributesGetPost: async (workflowGetSearchAttributesRequest, options = {}) => {
            const localVarPath = `/api/v1/workflow/searchattributes/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowGetSearchAttributesRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary signal a workflow
         * @param {WorkflowSignalRequest} [workflowSignalRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowSignalPost: async (workflowSignalRequest, options = {}) => {
            const localVarPath = `/api/v1/workflow/signal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowSignalRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary start a workflow
         * @param {WorkflowStartRequest} [workflowStartRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStartPost: async (workflowStartRequest, options = {}) => {
            const localVarPath = `/api/v1/workflow/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowStartRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary for invoking WorkflowState.decide API
         * @param {WorkflowStateDecideRequest} [workflowStateDecideRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStateDecidePost: async (workflowStateDecideRequest, options = {}) => {
            const localVarPath = `/api/v1/workflowState/decide`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowStateDecideRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary for invoking WorkflowState.start API
         * @param {WorkflowStateStartRequest} [workflowStateStartRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStateStartPost: async (workflowStateStartRequest, options = {}) => {
            const localVarPath = `/api/v1/workflowState/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowStateStartRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary stop a workflow
         * @param {WorkflowStopRequest} [workflowStopRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStopPost: async (workflowStopRequest, options = {}) => {
            const localVarPath = `/api/v1/workflow/stop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowStopRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary skip the timer of a workflow
         * @param {WorkflowSkipTimerRequest} [workflowSkipTimerRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowTimerSkipPost: async (workflowSkipTimerRequest, options = {}) => {
            const localVarPath = `/api/v1/workflow/timer/skip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowSkipTimerRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary for invoking workflow RPC API in the worker
         * @param {WorkflowWorkerRpcRequest} [workflowWorkerRpcRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowWorkerRpcPost: async (workflowWorkerRpcRequest, options = {}) => {
            const localVarPath = `/api/v1/workflowWorker/rpc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowWorkerRpcRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.DefaultApiAxiosParamCreator = DefaultApiAxiosParamCreator;
/**
 * DefaultApi - functional programming interface
 * @export
 */
const DefaultApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DefaultApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary update the config of a workflow
         * @param {WorkflowConfigUpdateRequest} [workflowConfigUpdateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowConfigUpdatePost(workflowConfigUpdateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowConfigUpdatePost(workflowConfigUpdateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary get workflow data objects
         * @param {WorkflowGetDataObjectsRequest} [workflowGetDataObjectsRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowDataobjectsGetPost(workflowGetDataObjectsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowDataobjectsGetPost(workflowGetDataObjectsRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary get a workflow\'s status and results(if completed & requested)
         * @param {WorkflowGetRequest} [workflowGetRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowGetPost(workflowGetRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowGetPost(workflowGetRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary get a workflow\'s status and results(if completed & requested), wait if the workflow is still running
         * @param {WorkflowGetRequest} [workflowGetRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowGetWithWaitPost(workflowGetRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowGetWithWaitPost(workflowGetRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary dump internal info of a workflow
         * @param {WorkflowDumpRequest} [workflowDumpRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowInternalDumpPost(workflowDumpRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowInternalDumpPost(workflowDumpRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary reset a workflow
         * @param {WorkflowResetRequest} [workflowResetRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowResetPost(workflowResetRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowResetPost(workflowResetRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary execute an RPC of a workflow
         * @param {WorkflowRpcRequest} [workflowRpcRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowRpcPost(workflowRpcRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowRpcPost(workflowRpcRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary search for workflows by a search attribute query
         * @param {WorkflowSearchRequest} [workflowSearchRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowSearchPost(workflowSearchRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowSearchPost(workflowSearchRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary get workflow search attributes
         * @param {WorkflowGetSearchAttributesRequest} [workflowGetSearchAttributesRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowSearchattributesGetPost(workflowGetSearchAttributesRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowSearchattributesGetPost(workflowGetSearchAttributesRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary signal a workflow
         * @param {WorkflowSignalRequest} [workflowSignalRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowSignalPost(workflowSignalRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowSignalPost(workflowSignalRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary start a workflow
         * @param {WorkflowStartRequest} [workflowStartRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowStartPost(workflowStartRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowStartPost(workflowStartRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary for invoking WorkflowState.decide API
         * @param {WorkflowStateDecideRequest} [workflowStateDecideRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowStateDecidePost(workflowStateDecideRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowStateDecidePost(workflowStateDecideRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary for invoking WorkflowState.start API
         * @param {WorkflowStateStartRequest} [workflowStateStartRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowStateStartPost(workflowStateStartRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowStateStartPost(workflowStateStartRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary stop a workflow
         * @param {WorkflowStopRequest} [workflowStopRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowStopPost(workflowStopRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowStopPost(workflowStopRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary skip the timer of a workflow
         * @param {WorkflowSkipTimerRequest} [workflowSkipTimerRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowTimerSkipPost(workflowSkipTimerRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowTimerSkipPost(workflowSkipTimerRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary for invoking workflow RPC API in the worker
         * @param {WorkflowWorkerRpcRequest} [workflowWorkerRpcRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowWorkerRpcPost(workflowWorkerRpcRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowWorkerRpcPost(workflowWorkerRpcRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.DefaultApiFp = DefaultApiFp;
/**
 * DefaultApi - factory interface
 * @export
 */
const DefaultApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DefaultApiFp)(configuration);
    return {
        /**
         *
         * @summary update the config of a workflow
         * @param {WorkflowConfigUpdateRequest} [workflowConfigUpdateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowConfigUpdatePost(workflowConfigUpdateRequest, options) {
            return localVarFp.apiV1WorkflowConfigUpdatePost(workflowConfigUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary get workflow data objects
         * @param {WorkflowGetDataObjectsRequest} [workflowGetDataObjectsRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowDataobjectsGetPost(workflowGetDataObjectsRequest, options) {
            return localVarFp.apiV1WorkflowDataobjectsGetPost(workflowGetDataObjectsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary get a workflow\'s status and results(if completed & requested)
         * @param {WorkflowGetRequest} [workflowGetRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowGetPost(workflowGetRequest, options) {
            return localVarFp.apiV1WorkflowGetPost(workflowGetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary get a workflow\'s status and results(if completed & requested), wait if the workflow is still running
         * @param {WorkflowGetRequest} [workflowGetRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowGetWithWaitPost(workflowGetRequest, options) {
            return localVarFp.apiV1WorkflowGetWithWaitPost(workflowGetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary dump internal info of a workflow
         * @param {WorkflowDumpRequest} [workflowDumpRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowInternalDumpPost(workflowDumpRequest, options) {
            return localVarFp.apiV1WorkflowInternalDumpPost(workflowDumpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary reset a workflow
         * @param {WorkflowResetRequest} [workflowResetRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowResetPost(workflowResetRequest, options) {
            return localVarFp.apiV1WorkflowResetPost(workflowResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary execute an RPC of a workflow
         * @param {WorkflowRpcRequest} [workflowRpcRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowRpcPost(workflowRpcRequest, options) {
            return localVarFp.apiV1WorkflowRpcPost(workflowRpcRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary search for workflows by a search attribute query
         * @param {WorkflowSearchRequest} [workflowSearchRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowSearchPost(workflowSearchRequest, options) {
            return localVarFp.apiV1WorkflowSearchPost(workflowSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary get workflow search attributes
         * @param {WorkflowGetSearchAttributesRequest} [workflowGetSearchAttributesRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowSearchattributesGetPost(workflowGetSearchAttributesRequest, options) {
            return localVarFp.apiV1WorkflowSearchattributesGetPost(workflowGetSearchAttributesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary signal a workflow
         * @param {WorkflowSignalRequest} [workflowSignalRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowSignalPost(workflowSignalRequest, options) {
            return localVarFp.apiV1WorkflowSignalPost(workflowSignalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary start a workflow
         * @param {WorkflowStartRequest} [workflowStartRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStartPost(workflowStartRequest, options) {
            return localVarFp.apiV1WorkflowStartPost(workflowStartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary for invoking WorkflowState.decide API
         * @param {WorkflowStateDecideRequest} [workflowStateDecideRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStateDecidePost(workflowStateDecideRequest, options) {
            return localVarFp.apiV1WorkflowStateDecidePost(workflowStateDecideRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary for invoking WorkflowState.start API
         * @param {WorkflowStateStartRequest} [workflowStateStartRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStateStartPost(workflowStateStartRequest, options) {
            return localVarFp.apiV1WorkflowStateStartPost(workflowStateStartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary stop a workflow
         * @param {WorkflowStopRequest} [workflowStopRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStopPost(workflowStopRequest, options) {
            return localVarFp.apiV1WorkflowStopPost(workflowStopRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary skip the timer of a workflow
         * @param {WorkflowSkipTimerRequest} [workflowSkipTimerRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowTimerSkipPost(workflowSkipTimerRequest, options) {
            return localVarFp.apiV1WorkflowTimerSkipPost(workflowSkipTimerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary for invoking workflow RPC API in the worker
         * @param {WorkflowWorkerRpcRequest} [workflowWorkerRpcRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowWorkerRpcPost(workflowWorkerRpcRequest, options) {
            return localVarFp.apiV1WorkflowWorkerRpcPost(workflowWorkerRpcRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.DefaultApiFactory = DefaultApiFactory;
/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
class DefaultApi extends base_1.BaseAPI {
    /**
     *
     * @summary update the config of a workflow
     * @param {WorkflowConfigUpdateRequest} [workflowConfigUpdateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowConfigUpdatePost(workflowConfigUpdateRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowConfigUpdatePost(workflowConfigUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary get workflow data objects
     * @param {WorkflowGetDataObjectsRequest} [workflowGetDataObjectsRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowDataobjectsGetPost(workflowGetDataObjectsRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowDataobjectsGetPost(workflowGetDataObjectsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary get a workflow\'s status and results(if completed & requested)
     * @param {WorkflowGetRequest} [workflowGetRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowGetPost(workflowGetRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowGetPost(workflowGetRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary get a workflow\'s status and results(if completed & requested), wait if the workflow is still running
     * @param {WorkflowGetRequest} [workflowGetRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowGetWithWaitPost(workflowGetRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowGetWithWaitPost(workflowGetRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary dump internal info of a workflow
     * @param {WorkflowDumpRequest} [workflowDumpRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowInternalDumpPost(workflowDumpRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowInternalDumpPost(workflowDumpRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary reset a workflow
     * @param {WorkflowResetRequest} [workflowResetRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowResetPost(workflowResetRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowResetPost(workflowResetRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary execute an RPC of a workflow
     * @param {WorkflowRpcRequest} [workflowRpcRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowRpcPost(workflowRpcRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowRpcPost(workflowRpcRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary search for workflows by a search attribute query
     * @param {WorkflowSearchRequest} [workflowSearchRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowSearchPost(workflowSearchRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowSearchPost(workflowSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary get workflow search attributes
     * @param {WorkflowGetSearchAttributesRequest} [workflowGetSearchAttributesRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowSearchattributesGetPost(workflowGetSearchAttributesRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowSearchattributesGetPost(workflowGetSearchAttributesRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary signal a workflow
     * @param {WorkflowSignalRequest} [workflowSignalRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowSignalPost(workflowSignalRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowSignalPost(workflowSignalRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary start a workflow
     * @param {WorkflowStartRequest} [workflowStartRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowStartPost(workflowStartRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowStartPost(workflowStartRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary for invoking WorkflowState.decide API
     * @param {WorkflowStateDecideRequest} [workflowStateDecideRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowStateDecidePost(workflowStateDecideRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowStateDecidePost(workflowStateDecideRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary for invoking WorkflowState.start API
     * @param {WorkflowStateStartRequest} [workflowStateStartRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowStateStartPost(workflowStateStartRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowStateStartPost(workflowStateStartRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary stop a workflow
     * @param {WorkflowStopRequest} [workflowStopRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowStopPost(workflowStopRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowStopPost(workflowStopRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary skip the timer of a workflow
     * @param {WorkflowSkipTimerRequest} [workflowSkipTimerRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowTimerSkipPost(workflowSkipTimerRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowTimerSkipPost(workflowSkipTimerRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary for invoking workflow RPC API in the worker
     * @param {WorkflowWorkerRpcRequest} [workflowWorkerRpcRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    apiV1WorkflowWorkerRpcPost(workflowWorkerRpcRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).apiV1WorkflowWorkerRpcPost(workflowWorkerRpcRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DefaultApi = DefaultApi;
