/* tslint:disable */
/* eslint-disable */
/**
 * Workflow APIs
 * This APIs for iwf SDKs to operate workflows
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const ChannelRequestStatus = {
    Waiting: 'WAITING',
    Received: 'RECEIVED'
} as const;

export type ChannelRequestStatus = typeof ChannelRequestStatus[keyof typeof ChannelRequestStatus];


/**
 * 
 * @export
 * @interface CommandCarryOverPolicy
 */
export interface CommandCarryOverPolicy {
    /**
     * 
     * @type {CommandCarryOverType}
     * @memberof CommandCarryOverPolicy
     */
    'commandCarryOverType'?: CommandCarryOverType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const CommandCarryOverType = {
    None: 'NONE'
} as const;

export type CommandCarryOverType = typeof CommandCarryOverType[keyof typeof CommandCarryOverType];


/**
 * 
 * @export
 * @interface CommandCombination
 */
export interface CommandCombination {
    /**
     * 
     * @type {Array<string>}
     * @memberof CommandCombination
     */
    'commandIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CommandRequest
 */
export interface CommandRequest {
    /**
     * 
     * @type {DeciderTriggerType}
     * @memberof CommandRequest
     */
    'deciderTriggerType'?: DeciderTriggerType;
    /**
     * 
     * @type {CommandWaitingType}
     * @memberof CommandRequest
     */
    'commandWaitingType'?: CommandWaitingType;
    /**
     * 
     * @type {Array<TimerCommand>}
     * @memberof CommandRequest
     */
    'timerCommands'?: Array<TimerCommand>;
    /**
     * 
     * @type {Array<SignalCommand>}
     * @memberof CommandRequest
     */
    'signalCommands'?: Array<SignalCommand>;
    /**
     * 
     * @type {Array<InterStateChannelCommand>}
     * @memberof CommandRequest
     */
    'interStateChannelCommands'?: Array<InterStateChannelCommand>;
    /**
     * 
     * @type {Array<CommandCombination>}
     * @memberof CommandRequest
     */
    'commandCombinations'?: Array<CommandCombination>;
}


/**
 * 
 * @export
 * @interface CommandResults
 */
export interface CommandResults {
    /**
     * 
     * @type {Array<SignalResult>}
     * @memberof CommandResults
     */
    'signalResults'?: Array<SignalResult>;
    /**
     * 
     * @type {Array<InterStateChannelResult>}
     * @memberof CommandResults
     */
    'interStateChannelResults'?: Array<InterStateChannelResult>;
    /**
     * 
     * @type {Array<TimerResult>}
     * @memberof CommandResults
     */
    'timerResults'?: Array<TimerResult>;
    /**
     * 
     * @type {boolean}
     * @memberof CommandResults
     */
    'stateStartApiSucceeded'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CommandWaitingType = {
    AllCompleted: 'ALL_COMPLETED',
    AnyCompleted: 'ANY_COMPLETED',
    AnyCombinationCompleted: 'ANY_COMBINATION_COMPLETED'
} as const;

export type CommandWaitingType = typeof CommandWaitingType[keyof typeof CommandWaitingType];


/**
 * 
 * @export
 * @interface Context
 */
export interface Context {
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'workflowId': string;
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'workflowRunId': string;
    /**
     * 
     * @type {number}
     * @memberof Context
     */
    'workflowStartedTimestamp': number;
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'stateExecutionId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Context
     */
    'firstAttemptTimestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof Context
     */
    'attempt'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DeciderTriggerType = {
    AllCommandCompleted: 'ALL_COMMAND_COMPLETED',
    AnyCommandCompleted: 'ANY_COMMAND_COMPLETED',
    AnyCommandCombinationCompleted: 'ANY_COMMAND_COMBINATION_COMPLETED'
} as const;

export type DeciderTriggerType = typeof DeciderTriggerType[keyof typeof DeciderTriggerType];


/**
 * 
 * @export
 * @interface EncodedObject
 */
export interface EncodedObject {
    /**
     * 
     * @type {string}
     * @memberof EncodedObject
     */
    'encoding'?: string;
    /**
     * 
     * @type {string}
     * @memberof EncodedObject
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'detail'?: string;
    /**
     * 
     * @type {ErrorSubStatus}
     * @memberof ErrorResponse
     */
    'subStatus'?: ErrorSubStatus;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'originalWorkerErrorDetail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'originalWorkerErrorType'?: string;
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'originalWorkerErrorStatus'?: number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ErrorSubStatus = {
    UncategorizedSubStatus: 'UNCATEGORIZED_SUB_STATUS',
    WorkflowAlreadyStartedSubStatus: 'WORKFLOW_ALREADY_STARTED_SUB_STATUS',
    WorkflowNotExistsSubStatus: 'WORKFLOW_NOT_EXISTS_SUB_STATUS',
    WorkerApiError: 'WORKER_API_ERROR'
} as const;

export type ErrorSubStatus = typeof ErrorSubStatus[keyof typeof ErrorSubStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const IDReusePolicy = {
    AllowIfPreviousExistsAbnormally: 'ALLOW_IF_PREVIOUS_EXISTS_ABNORMALLY',
    AllowIfNoRunning: 'ALLOW_IF_NO_RUNNING',
    DisallowReuse: 'DISALLOW_REUSE',
    AllowTerminateIfRunning: 'ALLOW_TERMINATE_IF_RUNNING'
} as const;

export type IDReusePolicy = typeof IDReusePolicy[keyof typeof IDReusePolicy];


/**
 * 
 * @export
 * @interface InterStateChannelCommand
 */
export interface InterStateChannelCommand {
    /**
     * 
     * @type {string}
     * @memberof InterStateChannelCommand
     */
    'commandId': string;
    /**
     * 
     * @type {string}
     * @memberof InterStateChannelCommand
     */
    'channelName': string;
}
/**
 * 
 * @export
 * @interface InterStateChannelPublishing
 */
export interface InterStateChannelPublishing {
    /**
     * 
     * @type {string}
     * @memberof InterStateChannelPublishing
     */
    'channelName': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof InterStateChannelPublishing
     */
    'value'?: EncodedObject;
}
/**
 * 
 * @export
 * @interface InterStateChannelResult
 */
export interface InterStateChannelResult {
    /**
     * 
     * @type {string}
     * @memberof InterStateChannelResult
     */
    'commandId': string;
    /**
     * 
     * @type {ChannelRequestStatus}
     * @memberof InterStateChannelResult
     */
    'requestStatus': ChannelRequestStatus;
    /**
     * 
     * @type {string}
     * @memberof InterStateChannelResult
     */
    'channelName': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof InterStateChannelResult
     */
    'value'?: EncodedObject;
}


/**
 * 
 * @export
 * @interface KeyValue
 */
export interface KeyValue {
    /**
     * 
     * @type {string}
     * @memberof KeyValue
     */
    'key'?: string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof KeyValue
     */
    'value'?: EncodedObject;
}
/**
 * 
 * @export
 * @interface PersistenceLoadingPolicy
 */
export interface PersistenceLoadingPolicy {
    /**
     * 
     * @type {PersistenceLoadingType}
     * @memberof PersistenceLoadingPolicy
     */
    'persistenceLoadingType'?: PersistenceLoadingType;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersistenceLoadingPolicy
     */
    'partialLoadingKeys'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PersistenceLoadingPolicy
     */
    'lockingKeys'?: Array<string>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PersistenceLoadingType = {
    AllWithoutLocking: 'LOAD_ALL_WITHOUT_LOCKING',
    PartialWithoutLocking: 'LOAD_PARTIAL_WITHOUT_LOCKING',
    PartialWithExclusiveLock: 'LOAD_PARTIAL_WITH_EXCLUSIVE_LOCK'
} as const;

export type PersistenceLoadingType = typeof PersistenceLoadingType[keyof typeof PersistenceLoadingType];


/**
 * 
 * @export
 * @interface RetryPolicy
 */
export interface RetryPolicy {
    /**
     * 
     * @type {number}
     * @memberof RetryPolicy
     */
    'initialIntervalSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof RetryPolicy
     */
    'backoffCoefficient'?: number;
    /**
     * 
     * @type {number}
     * @memberof RetryPolicy
     */
    'maximumIntervalSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof RetryPolicy
     */
    'maximumAttempts'?: number;
    /**
     * 
     * @type {number}
     * @memberof RetryPolicy
     */
    'maximumAttemptsDurationSeconds'?: number;
}
/**
 * 
 * @export
 * @interface SearchAttribute
 */
export interface SearchAttribute {
    /**
     * 
     * @type {string}
     * @memberof SearchAttribute
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchAttribute
     */
    'stringValue'?: string;
    /**
     * 
     * @type {number}
     * @memberof SearchAttribute
     */
    'integerValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchAttribute
     */
    'doubleValue'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SearchAttribute
     */
    'boolValue'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchAttribute
     */
    'stringArrayValue'?: Array<string>;
    /**
     * 
     * @type {SearchAttributeValueType}
     * @memberof SearchAttribute
     */
    'valueType'?: SearchAttributeValueType;
}


/**
 * 
 * @export
 * @interface SearchAttributeKeyAndType
 */
export interface SearchAttributeKeyAndType {
    /**
     * 
     * @type {string}
     * @memberof SearchAttributeKeyAndType
     */
    'key'?: string;
    /**
     * 
     * @type {SearchAttributeValueType}
     * @memberof SearchAttributeKeyAndType
     */
    'valueType'?: SearchAttributeValueType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SearchAttributeValueType = {
    Keyword: 'KEYWORD',
    Text: 'TEXT',
    Datetime: 'DATETIME',
    Int: 'INT',
    Double: 'DOUBLE',
    Bool: 'BOOL',
    KeywordArray: 'KEYWORD_ARRAY'
} as const;

export type SearchAttributeValueType = typeof SearchAttributeValueType[keyof typeof SearchAttributeValueType];


/**
 * 
 * @export
 * @interface SignalCommand
 */
export interface SignalCommand {
    /**
     * 
     * @type {string}
     * @memberof SignalCommand
     */
    'commandId': string;
    /**
     * 
     * @type {string}
     * @memberof SignalCommand
     */
    'signalChannelName': string;
}
/**
 * 
 * @export
 * @interface SignalResult
 */
export interface SignalResult {
    /**
     * 
     * @type {string}
     * @memberof SignalResult
     */
    'commandId': string;
    /**
     * 
     * @type {ChannelRequestStatus}
     * @memberof SignalResult
     */
    'signalRequestStatus': ChannelRequestStatus;
    /**
     * 
     * @type {string}
     * @memberof SignalResult
     */
    'signalChannelName': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof SignalResult
     */
    'signalValue'?: EncodedObject;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const StartApiFailurePolicy = {
    FailWorkflowOnStartApiFailure: 'FAIL_WORKFLOW_ON_START_API_FAILURE',
    ProceedToDecideOnStartApiFailure: 'PROCEED_TO_DECIDE_ON_START_API_FAILURE'
} as const;

export type StartApiFailurePolicy = typeof StartApiFailurePolicy[keyof typeof StartApiFailurePolicy];


/**
 * 
 * @export
 * @interface StateCompletionOutput
 */
export interface StateCompletionOutput {
    /**
     * 
     * @type {string}
     * @memberof StateCompletionOutput
     */
    'completedStateId': string;
    /**
     * 
     * @type {string}
     * @memberof StateCompletionOutput
     */
    'completedStateExecutionId': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof StateCompletionOutput
     */
    'completedStateOutput'?: EncodedObject;
}
/**
 * 
 * @export
 * @interface StateDecision
 */
export interface StateDecision {
    /**
     * 
     * @type {Array<StateMovement>}
     * @memberof StateDecision
     */
    'nextStates'?: Array<StateMovement>;
}
/**
 * 
 * @export
 * @interface StateMovement
 */
export interface StateMovement {
    /**
     * 
     * @type {string}
     * @memberof StateMovement
     */
    'stateId': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof StateMovement
     */
    'stateInput'?: EncodedObject;
    /**
     * 
     * @type {WorkflowStateOptions}
     * @memberof StateMovement
     */
    'stateOptions'?: WorkflowStateOptions;
}
/**
 * 
 * @export
 * @interface TimerCommand
 */
export interface TimerCommand {
    /**
     * 
     * @type {string}
     * @memberof TimerCommand
     */
    'commandId': string;
    /**
     * 
     * @type {number}
     * @memberof TimerCommand
     */
    'firingUnixTimestampSeconds': number;
}
/**
 * 
 * @export
 * @interface TimerResult
 */
export interface TimerResult {
    /**
     * 
     * @type {string}
     * @memberof TimerResult
     */
    'commandId': string;
    /**
     * 
     * @type {TimerStatus}
     * @memberof TimerResult
     */
    'timerStatus': TimerStatus;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TimerStatus = {
    Scheduled: 'SCHEDULED',
    Fired: 'FIRED'
} as const;

export type TimerStatus = typeof TimerStatus[keyof typeof TimerStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const WaitUntilApiFailurePolicy = {
    FailWorkflowOnFailure: 'FAIL_WORKFLOW_ON_FAILURE',
    ProceedOnFailure: 'PROCEED_ON_FAILURE'
} as const;

export type WaitUntilApiFailurePolicy = typeof WaitUntilApiFailurePolicy[keyof typeof WaitUntilApiFailurePolicy];


/**
 * 
 * @export
 * @interface WorkerErrorResponse
 */
export interface WorkerErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof WorkerErrorResponse
     */
    'detail'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerErrorResponse
     */
    'errorType'?: string;
}
/**
 * 
 * @export
 * @interface WorkflowConfig
 */
export interface WorkflowConfig {
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowConfig
     */
    'disableSystemSearchAttribute'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WorkflowConfig
     */
    'continueAsNewThreshold'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowConfig
     */
    'continueAsNewPageSizeInBytes'?: number;
}
/**
 * 
 * @export
 * @interface WorkflowConfigUpdateRequest
 */
export interface WorkflowConfigUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowConfigUpdateRequest
     */
    'workflowId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowConfigUpdateRequest
     */
    'workflowRunId'?: string;
    /**
     * 
     * @type {WorkflowConfig}
     * @memberof WorkflowConfigUpdateRequest
     */
    'workflowConfig': WorkflowConfig;
}
/**
 * 
 * @export
 * @interface WorkflowDumpRequest
 */
export interface WorkflowDumpRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowDumpRequest
     */
    'workflowId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDumpRequest
     */
    'workflowRunId': string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowDumpRequest
     */
    'pageSizeInBytes': number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowDumpRequest
     */
    'pageNum': number;
}
/**
 * 
 * @export
 * @interface WorkflowDumpResponse
 */
export interface WorkflowDumpResponse {
    /**
     * 
     * @type {string}
     * @memberof WorkflowDumpResponse
     */
    'checksum': string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowDumpResponse
     */
    'totalPages': number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowDumpResponse
     */
    'jsonData': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WorkflowErrorType = {
    StateDecisionFailingWorkflowErrorType: 'STATE_DECISION_FAILING_WORKFLOW_ERROR_TYPE',
    ClientApiFailingWorkflowErrorType: 'CLIENT_API_FAILING_WORKFLOW_ERROR_TYPE',
    StateApiFailMaxOutRetryErrorType: 'STATE_API_FAIL_MAX_OUT_RETRY_ERROR_TYPE',
    InvalidUserWorkflowCodeErrorType: 'INVALID_USER_WORKFLOW_CODE_ERROR_TYPE',
    ServerInternalErrorType: 'SERVER_INTERNAL_ERROR_TYPE'
} as const;

export type WorkflowErrorType = typeof WorkflowErrorType[keyof typeof WorkflowErrorType];


/**
 * 
 * @export
 * @interface WorkflowGetDataObjectsRequest
 */
export interface WorkflowGetDataObjectsRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowGetDataObjectsRequest
     */
    'workflowId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowGetDataObjectsRequest
     */
    'workflowRunId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkflowGetDataObjectsRequest
     */
    'keys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WorkflowGetDataObjectsResponse
 */
export interface WorkflowGetDataObjectsResponse {
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof WorkflowGetDataObjectsResponse
     */
    'objects'?: Array<KeyValue>;
}
/**
 * 
 * @export
 * @interface WorkflowGetRequest
 */
export interface WorkflowGetRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowGetRequest
     */
    'workflowId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowGetRequest
     */
    'workflowRunId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowGetRequest
     */
    'needsResults'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WorkflowGetRequest
     */
    'waitTimeSeconds'?: number;
}
/**
 * 
 * @export
 * @interface WorkflowGetResponse
 */
export interface WorkflowGetResponse {
    /**
     * 
     * @type {string}
     * @memberof WorkflowGetResponse
     */
    'workflowRunId': string;
    /**
     * 
     * @type {WorkflowStatus}
     * @memberof WorkflowGetResponse
     */
    'workflowStatus': WorkflowStatus;
    /**
     * 
     * @type {Array<StateCompletionOutput>}
     * @memberof WorkflowGetResponse
     */
    'results'?: Array<StateCompletionOutput>;
    /**
     * 
     * @type {WorkflowErrorType}
     * @memberof WorkflowGetResponse
     */
    'errorType'?: WorkflowErrorType;
    /**
     * 
     * @type {string}
     * @memberof WorkflowGetResponse
     */
    'errorMessage'?: string;
}


/**
 * 
 * @export
 * @interface WorkflowGetSearchAttributesRequest
 */
export interface WorkflowGetSearchAttributesRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowGetSearchAttributesRequest
     */
    'workflowId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowGetSearchAttributesRequest
     */
    'workflowRunId'?: string;
    /**
     * 
     * @type {Array<SearchAttributeKeyAndType>}
     * @memberof WorkflowGetSearchAttributesRequest
     */
    'keys'?: Array<SearchAttributeKeyAndType>;
}
/**
 * 
 * @export
 * @interface WorkflowGetSearchAttributesResponse
 */
export interface WorkflowGetSearchAttributesResponse {
    /**
     * 
     * @type {Array<SearchAttribute>}
     * @memberof WorkflowGetSearchAttributesResponse
     */
    'searchAttributes'?: Array<SearchAttribute>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WorkflowIDReusePolicy = {
    AllowDuplicateFailedOnly: 'ALLOW_DUPLICATE_FAILED_ONLY',
    AllowDuplicate: 'ALLOW_DUPLICATE',
    RejectDuplicate: 'REJECT_DUPLICATE',
    TerminateIfRunning: 'TERMINATE_IF_RUNNING'
} as const;

export type WorkflowIDReusePolicy = typeof WorkflowIDReusePolicy[keyof typeof WorkflowIDReusePolicy];


/**
 * 
 * @export
 * @interface WorkflowResetRequest
 */
export interface WorkflowResetRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowResetRequest
     */
    'workflowId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResetRequest
     */
    'workflowRunId'?: string;
    /**
     * 
     * @type {WorkflowResetType}
     * @memberof WorkflowResetRequest
     */
    'resetType': WorkflowResetType;
    /**
     * 
     * @type {number}
     * @memberof WorkflowResetRequest
     */
    'historyEventId'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResetRequest
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResetRequest
     */
    'historyEventTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResetRequest
     */
    'stateId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowResetRequest
     */
    'stateExecutionId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowResetRequest
     */
    'skipSignalReapply'?: boolean;
}


/**
 * 
 * @export
 * @interface WorkflowResetResponse
 */
export interface WorkflowResetResponse {
    /**
     * 
     * @type {string}
     * @memberof WorkflowResetResponse
     */
    'workflowRunId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WorkflowResetType = {
    HistoryEventId: 'HISTORY_EVENT_ID',
    Beginning: 'BEGINNING',
    HistoryEventTime: 'HISTORY_EVENT_TIME',
    StateId: 'STATE_ID',
    StateExecutionId: 'STATE_EXECUTION_ID'
} as const;

export type WorkflowResetType = typeof WorkflowResetType[keyof typeof WorkflowResetType];


/**
 * 
 * @export
 * @interface WorkflowRetryPolicy
 */
export interface WorkflowRetryPolicy {
    /**
     * 
     * @type {number}
     * @memberof WorkflowRetryPolicy
     */
    'initialIntervalSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowRetryPolicy
     */
    'backoffCoefficient'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowRetryPolicy
     */
    'maximumIntervalSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowRetryPolicy
     */
    'maximumAttempts'?: number;
}
/**
 * 
 * @export
 * @interface WorkflowRpcRequest
 */
export interface WorkflowRpcRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowRpcRequest
     */
    'workflowId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowRpcRequest
     */
    'workflowRunId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowRpcRequest
     */
    'rpcName': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof WorkflowRpcRequest
     */
    'input'?: EncodedObject;
    /**
     * 
     * @type {PersistenceLoadingPolicy}
     * @memberof WorkflowRpcRequest
     */
    'searchAttributesLoadingPolicy'?: PersistenceLoadingPolicy;
    /**
     * 
     * @type {PersistenceLoadingPolicy}
     * @memberof WorkflowRpcRequest
     */
    'dataAttributesLoadingPolicy'?: PersistenceLoadingPolicy;
    /**
     * 
     * @type {number}
     * @memberof WorkflowRpcRequest
     */
    'timeoutSeconds'?: number;
}
/**
 * 
 * @export
 * @interface WorkflowRpcResponse
 */
export interface WorkflowRpcResponse {
    /**
     * 
     * @type {EncodedObject}
     * @memberof WorkflowRpcResponse
     */
    'output'?: EncodedObject;
}
/**
 * 
 * @export
 * @interface WorkflowSearchRequest
 */
export interface WorkflowSearchRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowSearchRequest
     */
    'query': string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowSearchRequest
     */
    'pageSize'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowSearchRequest
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface WorkflowSearchResponse
 */
export interface WorkflowSearchResponse {
    /**
     * 
     * @type {Array<WorkflowSearchResponseEntry>}
     * @memberof WorkflowSearchResponse
     */
    'workflowExecutions'?: Array<WorkflowSearchResponseEntry>;
    /**
     * 
     * @type {string}
     * @memberof WorkflowSearchResponse
     */
    'nextPageToken'?: string;
}
/**
 * 
 * @export
 * @interface WorkflowSearchResponseEntry
 */
export interface WorkflowSearchResponseEntry {
    /**
     * 
     * @type {string}
     * @memberof WorkflowSearchResponseEntry
     */
    'workflowId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowSearchResponseEntry
     */
    'workflowRunId': string;
}
/**
 * 
 * @export
 * @interface WorkflowSignalRequest
 */
export interface WorkflowSignalRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowSignalRequest
     */
    'workflowId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowSignalRequest
     */
    'workflowRunId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowSignalRequest
     */
    'signalChannelName': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof WorkflowSignalRequest
     */
    'signalValue'?: EncodedObject;
}
/**
 * 
 * @export
 * @interface WorkflowSkipTimerRequest
 */
export interface WorkflowSkipTimerRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowSkipTimerRequest
     */
    'workflowId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowSkipTimerRequest
     */
    'workflowRunId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowSkipTimerRequest
     */
    'workflowStateExecutionId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowSkipTimerRequest
     */
    'timerCommandId'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowSkipTimerRequest
     */
    'timerCommandIndex'?: number;
}
/**
 * 
 * @export
 * @interface WorkflowStartOptions
 */
export interface WorkflowStartOptions {
    /**
     * 
     * @type {WorkflowIDReusePolicy}
     * @memberof WorkflowStartOptions
     */
    'workflowIDReusePolicy'?: WorkflowIDReusePolicy;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStartOptions
     */
    'cronSchedule'?: string;
    /**
     * 
     * @type {WorkflowRetryPolicy}
     * @memberof WorkflowStartOptions
     */
    'retryPolicy'?: WorkflowRetryPolicy;
    /**
     * 
     * @type {Array<SearchAttribute>}
     * @memberof WorkflowStartOptions
     */
    'searchAttributes'?: Array<SearchAttribute>;
    /**
     * 
     * @type {WorkflowConfig}
     * @memberof WorkflowStartOptions
     */
    'workflowConfigOverride'?: WorkflowConfig;
    /**
     * 
     * @type {IDReusePolicy}
     * @memberof WorkflowStartOptions
     */
    'idReusePolicy'?: IDReusePolicy;
}


/**
 * 
 * @export
 * @interface WorkflowStartRequest
 */
export interface WorkflowStartRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowStartRequest
     */
    'workflowId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStartRequest
     */
    'iwfWorkflowType': string;
    /**
     * 
     * @type {number}
     * @memberof WorkflowStartRequest
     */
    'workflowTimeoutSeconds': number;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStartRequest
     */
    'iwfWorkerUrl': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStartRequest
     */
    'startStateId'?: string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof WorkflowStartRequest
     */
    'stateInput'?: EncodedObject;
    /**
     * 
     * @type {WorkflowStateOptions}
     * @memberof WorkflowStartRequest
     */
    'stateOptions'?: WorkflowStateOptions;
    /**
     * 
     * @type {WorkflowStartOptions}
     * @memberof WorkflowStartRequest
     */
    'workflowStartOptions'?: WorkflowStartOptions;
}
/**
 * 
 * @export
 * @interface WorkflowStartResponse
 */
export interface WorkflowStartResponse {
    /**
     * 
     * @type {string}
     * @memberof WorkflowStartResponse
     */
    'workflowRunId'?: string;
}
/**
 * 
 * @export
 * @interface WorkflowStateDecideRequest
 */
export interface WorkflowStateDecideRequest {
    /**
     * 
     * @type {Context}
     * @memberof WorkflowStateDecideRequest
     */
    'context': Context;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStateDecideRequest
     */
    'workflowType': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStateDecideRequest
     */
    'workflowStateId': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof WorkflowStateDecideRequest
     */
    'stateInput'?: EncodedObject;
    /**
     * 
     * @type {Array<SearchAttribute>}
     * @memberof WorkflowStateDecideRequest
     */
    'searchAttributes'?: Array<SearchAttribute>;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof WorkflowStateDecideRequest
     */
    'DataObjects'?: Array<KeyValue>;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof WorkflowStateDecideRequest
     */
    'stateLocals'?: Array<KeyValue>;
    /**
     * 
     * @type {CommandResults}
     * @memberof WorkflowStateDecideRequest
     */
    'commandResults'?: CommandResults;
}
/**
 * 
 * @export
 * @interface WorkflowStateDecideResponse
 */
export interface WorkflowStateDecideResponse {
    /**
     * 
     * @type {StateDecision}
     * @memberof WorkflowStateDecideResponse
     */
    'stateDecision'?: StateDecision;
    /**
     * 
     * @type {Array<SearchAttribute>}
     * @memberof WorkflowStateDecideResponse
     */
    'upsertSearchAttributes'?: Array<SearchAttribute>;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof WorkflowStateDecideResponse
     */
    'upsertDataObjects'?: Array<KeyValue>;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof WorkflowStateDecideResponse
     */
    'recordEvents'?: Array<KeyValue>;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof WorkflowStateDecideResponse
     */
    'upsertStateLocals'?: Array<KeyValue>;
    /**
     * 
     * @type {Array<InterStateChannelPublishing>}
     * @memberof WorkflowStateDecideResponse
     */
    'publishToInterStateChannel'?: Array<InterStateChannelPublishing>;
}
/**
 * 
 * @export
 * @interface WorkflowStateOptions
 */
export interface WorkflowStateOptions {
    /**
     * 
     * @type {PersistenceLoadingPolicy}
     * @memberof WorkflowStateOptions
     */
    'searchAttributesLoadingPolicy'?: PersistenceLoadingPolicy;
    /**
     * 
     * @type {PersistenceLoadingPolicy}
     * @memberof WorkflowStateOptions
     */
    'dataObjectsLoadingPolicy'?: PersistenceLoadingPolicy;
    /**
     * 
     * @type {CommandCarryOverPolicy}
     * @memberof WorkflowStateOptions
     */
    'commandCarryOverPolicy'?: CommandCarryOverPolicy;
    /**
     * 
     * @type {number}
     * @memberof WorkflowStateOptions
     */
    'startApiTimeoutSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowStateOptions
     */
    'decideApiTimeoutSeconds'?: number;
    /**
     * 
     * @type {RetryPolicy}
     * @memberof WorkflowStateOptions
     */
    'startApiRetryPolicy'?: RetryPolicy;
    /**
     * 
     * @type {RetryPolicy}
     * @memberof WorkflowStateOptions
     */
    'decideApiRetryPolicy'?: RetryPolicy;
    /**
     * 
     * @type {StartApiFailurePolicy}
     * @memberof WorkflowStateOptions
     */
    'startApiFailurePolicy'?: StartApiFailurePolicy;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowStateOptions
     */
    'skipStartApi'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WorkflowStateOptions
     */
    'waitUntilApiTimeoutSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowStateOptions
     */
    'executeApiTimeoutSeconds'?: number;
    /**
     * 
     * @type {RetryPolicy}
     * @memberof WorkflowStateOptions
     */
    'waitUntilApiRetryPolicy'?: RetryPolicy;
    /**
     * 
     * @type {RetryPolicy}
     * @memberof WorkflowStateOptions
     */
    'executeApiRetryPolicy'?: RetryPolicy;
    /**
     * 
     * @type {WaitUntilApiFailurePolicy}
     * @memberof WorkflowStateOptions
     */
    'waitUntilApiFailurePolicy'?: WaitUntilApiFailurePolicy;
    /**
     * 
     * @type {boolean}
     * @memberof WorkflowStateOptions
     */
    'skipWaitUntil'?: boolean;
    /**
     * 
     * @type {PersistenceLoadingPolicy}
     * @memberof WorkflowStateOptions
     */
    'dataAttributesLoadingPolicy'?: PersistenceLoadingPolicy;
}


/**
 * 
 * @export
 * @interface WorkflowStateStartRequest
 */
export interface WorkflowStateStartRequest {
    /**
     * 
     * @type {Context}
     * @memberof WorkflowStateStartRequest
     */
    'context': Context;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStateStartRequest
     */
    'workflowType': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStateStartRequest
     */
    'workflowStateId': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof WorkflowStateStartRequest
     */
    'stateInput'?: EncodedObject;
    /**
     * 
     * @type {Array<SearchAttribute>}
     * @memberof WorkflowStateStartRequest
     */
    'searchAttributes'?: Array<SearchAttribute>;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof WorkflowStateStartRequest
     */
    'dataObjects'?: Array<KeyValue>;
}
/**
 * 
 * @export
 * @interface WorkflowStateStartResponse
 */
export interface WorkflowStateStartResponse {
    /**
     * 
     * @type {Array<SearchAttribute>}
     * @memberof WorkflowStateStartResponse
     */
    'upsertSearchAttributes'?: Array<SearchAttribute>;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof WorkflowStateStartResponse
     */
    'upsertDataObjects'?: Array<KeyValue>;
    /**
     * 
     * @type {CommandRequest}
     * @memberof WorkflowStateStartResponse
     */
    'commandRequest'?: CommandRequest;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof WorkflowStateStartResponse
     */
    'upsertStateLocals'?: Array<KeyValue>;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof WorkflowStateStartResponse
     */
    'recordEvents'?: Array<KeyValue>;
    /**
     * 
     * @type {Array<InterStateChannelPublishing>}
     * @memberof WorkflowStateStartResponse
     */
    'publishToInterStateChannel'?: Array<InterStateChannelPublishing>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WorkflowStatus = {
    Running: 'RUNNING',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Timeout: 'TIMEOUT',
    Terminated: 'TERMINATED',
    Canceled: 'CANCELED',
    ContinuedAsNew: 'CONTINUED_AS_NEW'
} as const;

export type WorkflowStatus = typeof WorkflowStatus[keyof typeof WorkflowStatus];


/**
 * 
 * @export
 * @interface WorkflowStopRequest
 */
export interface WorkflowStopRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkflowStopRequest
     */
    'workflowId': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStopRequest
     */
    'workflowRunId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowStopRequest
     */
    'reason'?: string;
    /**
     * 
     * @type {WorkflowStopType}
     * @memberof WorkflowStopRequest
     */
    'stopType'?: WorkflowStopType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WorkflowStopType = {
    Cancel: 'CANCEL',
    Terminate: 'TERMINATE',
    Fail: 'FAIL'
} as const;

export type WorkflowStopType = typeof WorkflowStopType[keyof typeof WorkflowStopType];


/**
 * 
 * @export
 * @interface WorkflowWorkerRpcRequest
 */
export interface WorkflowWorkerRpcRequest {
    /**
     * 
     * @type {Context}
     * @memberof WorkflowWorkerRpcRequest
     */
    'context': Context;
    /**
     * 
     * @type {string}
     * @memberof WorkflowWorkerRpcRequest
     */
    'workflowType': string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowWorkerRpcRequest
     */
    'rpcName': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof WorkflowWorkerRpcRequest
     */
    'input'?: EncodedObject;
    /**
     * 
     * @type {Array<SearchAttribute>}
     * @memberof WorkflowWorkerRpcRequest
     */
    'searchAttributes'?: Array<SearchAttribute>;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof WorkflowWorkerRpcRequest
     */
    'dataAttributes'?: Array<KeyValue>;
}
/**
 * 
 * @export
 * @interface WorkflowWorkerRpcResponse
 */
export interface WorkflowWorkerRpcResponse {
    /**
     * 
     * @type {EncodedObject}
     * @memberof WorkflowWorkerRpcResponse
     */
    'output'?: EncodedObject;
    /**
     * 
     * @type {StateDecision}
     * @memberof WorkflowWorkerRpcResponse
     */
    'stateDecision'?: StateDecision;
    /**
     * 
     * @type {Array<SearchAttribute>}
     * @memberof WorkflowWorkerRpcResponse
     */
    'upsertSearchAttributes'?: Array<SearchAttribute>;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof WorkflowWorkerRpcResponse
     */
    'upsertDataAttributes'?: Array<KeyValue>;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof WorkflowWorkerRpcResponse
     */
    'recordEvents'?: Array<KeyValue>;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof WorkflowWorkerRpcResponse
     */
    'upsertStateLocals'?: Array<KeyValue>;
    /**
     * 
     * @type {Array<InterStateChannelPublishing>}
     * @memberof WorkflowWorkerRpcResponse
     */
    'publishToInterStateChannel'?: Array<InterStateChannelPublishing>;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary update the config of a workflow
         * @param {WorkflowConfigUpdateRequest} [workflowConfigUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowConfigUpdatePost: async (workflowConfigUpdateRequest?: WorkflowConfigUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflow/config/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowConfigUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get workflow data objects
         * @param {WorkflowGetDataObjectsRequest} [workflowGetDataObjectsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowDataobjectsGetPost: async (workflowGetDataObjectsRequest?: WorkflowGetDataObjectsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflow/dataobjects/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowGetDataObjectsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get a workflow\'s status and results(if completed & requested)
         * @param {WorkflowGetRequest} [workflowGetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowGetPost: async (workflowGetRequest?: WorkflowGetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflow/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowGetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get a workflow\'s status and results(if completed & requested), wait if the workflow is still running
         * @param {WorkflowGetRequest} [workflowGetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowGetWithWaitPost: async (workflowGetRequest?: WorkflowGetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflow/getWithWait`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowGetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary dump internal info of a workflow
         * @param {WorkflowDumpRequest} [workflowDumpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowInternalDumpPost: async (workflowDumpRequest?: WorkflowDumpRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflow/internal/dump`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowDumpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary reset a workflow
         * @param {WorkflowResetRequest} [workflowResetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowResetPost: async (workflowResetRequest?: WorkflowResetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflow/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowResetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary execute an RPC of a workflow
         * @param {WorkflowRpcRequest} [workflowRpcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowRpcPost: async (workflowRpcRequest?: WorkflowRpcRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflow/rpc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowRpcRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary search for workflows by a search attribute query
         * @param {WorkflowSearchRequest} [workflowSearchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowSearchPost: async (workflowSearchRequest?: WorkflowSearchRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflow/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get workflow search attributes
         * @param {WorkflowGetSearchAttributesRequest} [workflowGetSearchAttributesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowSearchattributesGetPost: async (workflowGetSearchAttributesRequest?: WorkflowGetSearchAttributesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflow/searchattributes/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowGetSearchAttributesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary signal a workflow
         * @param {WorkflowSignalRequest} [workflowSignalRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowSignalPost: async (workflowSignalRequest?: WorkflowSignalRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflow/signal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowSignalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary start a workflow
         * @param {WorkflowStartRequest} [workflowStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStartPost: async (workflowStartRequest?: WorkflowStartRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflow/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowStartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary for invoking WorkflowState.decide API
         * @param {WorkflowStateDecideRequest} [workflowStateDecideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStateDecidePost: async (workflowStateDecideRequest?: WorkflowStateDecideRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflowState/decide`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowStateDecideRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary for invoking WorkflowState.start API
         * @param {WorkflowStateStartRequest} [workflowStateStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStateStartPost: async (workflowStateStartRequest?: WorkflowStateStartRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflowState/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowStateStartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary stop a workflow
         * @param {WorkflowStopRequest} [workflowStopRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStopPost: async (workflowStopRequest?: WorkflowStopRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflow/stop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowStopRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary skip the timer of a workflow
         * @param {WorkflowSkipTimerRequest} [workflowSkipTimerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowTimerSkipPost: async (workflowSkipTimerRequest?: WorkflowSkipTimerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflow/timer/skip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowSkipTimerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary for invoking workflow RPC API in the worker
         * @param {WorkflowWorkerRpcRequest} [workflowWorkerRpcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowWorkerRpcPost: async (workflowWorkerRpcRequest?: WorkflowWorkerRpcRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflowWorker/rpc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowWorkerRpcRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary update the config of a workflow
         * @param {WorkflowConfigUpdateRequest} [workflowConfigUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowConfigUpdatePost(workflowConfigUpdateRequest?: WorkflowConfigUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowConfigUpdatePost(workflowConfigUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get workflow data objects
         * @param {WorkflowGetDataObjectsRequest} [workflowGetDataObjectsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowDataobjectsGetPost(workflowGetDataObjectsRequest?: WorkflowGetDataObjectsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowGetDataObjectsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowDataobjectsGetPost(workflowGetDataObjectsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get a workflow\'s status and results(if completed & requested)
         * @param {WorkflowGetRequest} [workflowGetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowGetPost(workflowGetRequest?: WorkflowGetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowGetPost(workflowGetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get a workflow\'s status and results(if completed & requested), wait if the workflow is still running
         * @param {WorkflowGetRequest} [workflowGetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowGetWithWaitPost(workflowGetRequest?: WorkflowGetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowGetWithWaitPost(workflowGetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary dump internal info of a workflow
         * @param {WorkflowDumpRequest} [workflowDumpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowInternalDumpPost(workflowDumpRequest?: WorkflowDumpRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowDumpResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowInternalDumpPost(workflowDumpRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary reset a workflow
         * @param {WorkflowResetRequest} [workflowResetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowResetPost(workflowResetRequest?: WorkflowResetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowResetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowResetPost(workflowResetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary execute an RPC of a workflow
         * @param {WorkflowRpcRequest} [workflowRpcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowRpcPost(workflowRpcRequest?: WorkflowRpcRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowRpcResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowRpcPost(workflowRpcRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary search for workflows by a search attribute query
         * @param {WorkflowSearchRequest} [workflowSearchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowSearchPost(workflowSearchRequest?: WorkflowSearchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowSearchPost(workflowSearchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get workflow search attributes
         * @param {WorkflowGetSearchAttributesRequest} [workflowGetSearchAttributesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowSearchattributesGetPost(workflowGetSearchAttributesRequest?: WorkflowGetSearchAttributesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowGetSearchAttributesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowSearchattributesGetPost(workflowGetSearchAttributesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary signal a workflow
         * @param {WorkflowSignalRequest} [workflowSignalRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowSignalPost(workflowSignalRequest?: WorkflowSignalRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowSignalPost(workflowSignalRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary start a workflow
         * @param {WorkflowStartRequest} [workflowStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowStartPost(workflowStartRequest?: WorkflowStartRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowStartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowStartPost(workflowStartRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary for invoking WorkflowState.decide API
         * @param {WorkflowStateDecideRequest} [workflowStateDecideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowStateDecidePost(workflowStateDecideRequest?: WorkflowStateDecideRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowStateDecideResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowStateDecidePost(workflowStateDecideRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary for invoking WorkflowState.start API
         * @param {WorkflowStateStartRequest} [workflowStateStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowStateStartPost(workflowStateStartRequest?: WorkflowStateStartRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowStateStartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowStateStartPost(workflowStateStartRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary stop a workflow
         * @param {WorkflowStopRequest} [workflowStopRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowStopPost(workflowStopRequest?: WorkflowStopRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowStopPost(workflowStopRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary skip the timer of a workflow
         * @param {WorkflowSkipTimerRequest} [workflowSkipTimerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowTimerSkipPost(workflowSkipTimerRequest?: WorkflowSkipTimerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowTimerSkipPost(workflowSkipTimerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary for invoking workflow RPC API in the worker
         * @param {WorkflowWorkerRpcRequest} [workflowWorkerRpcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkflowWorkerRpcPost(workflowWorkerRpcRequest?: WorkflowWorkerRpcRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowWorkerRpcResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkflowWorkerRpcPost(workflowWorkerRpcRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary update the config of a workflow
         * @param {WorkflowConfigUpdateRequest} [workflowConfigUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowConfigUpdatePost(workflowConfigUpdateRequest?: WorkflowConfigUpdateRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1WorkflowConfigUpdatePost(workflowConfigUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get workflow data objects
         * @param {WorkflowGetDataObjectsRequest} [workflowGetDataObjectsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowDataobjectsGetPost(workflowGetDataObjectsRequest?: WorkflowGetDataObjectsRequest, options?: any): AxiosPromise<WorkflowGetDataObjectsResponse> {
            return localVarFp.apiV1WorkflowDataobjectsGetPost(workflowGetDataObjectsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get a workflow\'s status and results(if completed & requested)
         * @param {WorkflowGetRequest} [workflowGetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowGetPost(workflowGetRequest?: WorkflowGetRequest, options?: any): AxiosPromise<WorkflowGetResponse> {
            return localVarFp.apiV1WorkflowGetPost(workflowGetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get a workflow\'s status and results(if completed & requested), wait if the workflow is still running
         * @param {WorkflowGetRequest} [workflowGetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowGetWithWaitPost(workflowGetRequest?: WorkflowGetRequest, options?: any): AxiosPromise<WorkflowGetResponse> {
            return localVarFp.apiV1WorkflowGetWithWaitPost(workflowGetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary dump internal info of a workflow
         * @param {WorkflowDumpRequest} [workflowDumpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowInternalDumpPost(workflowDumpRequest?: WorkflowDumpRequest, options?: any): AxiosPromise<WorkflowDumpResponse> {
            return localVarFp.apiV1WorkflowInternalDumpPost(workflowDumpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary reset a workflow
         * @param {WorkflowResetRequest} [workflowResetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowResetPost(workflowResetRequest?: WorkflowResetRequest, options?: any): AxiosPromise<WorkflowResetResponse> {
            return localVarFp.apiV1WorkflowResetPost(workflowResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary execute an RPC of a workflow
         * @param {WorkflowRpcRequest} [workflowRpcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowRpcPost(workflowRpcRequest?: WorkflowRpcRequest, options?: any): AxiosPromise<WorkflowRpcResponse> {
            return localVarFp.apiV1WorkflowRpcPost(workflowRpcRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary search for workflows by a search attribute query
         * @param {WorkflowSearchRequest} [workflowSearchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowSearchPost(workflowSearchRequest?: WorkflowSearchRequest, options?: any): AxiosPromise<WorkflowSearchResponse> {
            return localVarFp.apiV1WorkflowSearchPost(workflowSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get workflow search attributes
         * @param {WorkflowGetSearchAttributesRequest} [workflowGetSearchAttributesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowSearchattributesGetPost(workflowGetSearchAttributesRequest?: WorkflowGetSearchAttributesRequest, options?: any): AxiosPromise<WorkflowGetSearchAttributesResponse> {
            return localVarFp.apiV1WorkflowSearchattributesGetPost(workflowGetSearchAttributesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary signal a workflow
         * @param {WorkflowSignalRequest} [workflowSignalRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowSignalPost(workflowSignalRequest?: WorkflowSignalRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1WorkflowSignalPost(workflowSignalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary start a workflow
         * @param {WorkflowStartRequest} [workflowStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStartPost(workflowStartRequest?: WorkflowStartRequest, options?: any): AxiosPromise<WorkflowStartResponse> {
            return localVarFp.apiV1WorkflowStartPost(workflowStartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary for invoking WorkflowState.decide API
         * @param {WorkflowStateDecideRequest} [workflowStateDecideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStateDecidePost(workflowStateDecideRequest?: WorkflowStateDecideRequest, options?: any): AxiosPromise<WorkflowStateDecideResponse> {
            return localVarFp.apiV1WorkflowStateDecidePost(workflowStateDecideRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary for invoking WorkflowState.start API
         * @param {WorkflowStateStartRequest} [workflowStateStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStateStartPost(workflowStateStartRequest?: WorkflowStateStartRequest, options?: any): AxiosPromise<WorkflowStateStartResponse> {
            return localVarFp.apiV1WorkflowStateStartPost(workflowStateStartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary stop a workflow
         * @param {WorkflowStopRequest} [workflowStopRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowStopPost(workflowStopRequest?: WorkflowStopRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1WorkflowStopPost(workflowStopRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary skip the timer of a workflow
         * @param {WorkflowSkipTimerRequest} [workflowSkipTimerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowTimerSkipPost(workflowSkipTimerRequest?: WorkflowSkipTimerRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1WorkflowTimerSkipPost(workflowSkipTimerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary for invoking workflow RPC API in the worker
         * @param {WorkflowWorkerRpcRequest} [workflowWorkerRpcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkflowWorkerRpcPost(workflowWorkerRpcRequest?: WorkflowWorkerRpcRequest, options?: any): AxiosPromise<WorkflowWorkerRpcResponse> {
            return localVarFp.apiV1WorkflowWorkerRpcPost(workflowWorkerRpcRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary update the config of a workflow
     * @param {WorkflowConfigUpdateRequest} [workflowConfigUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowConfigUpdatePost(workflowConfigUpdateRequest?: WorkflowConfigUpdateRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowConfigUpdatePost(workflowConfigUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get workflow data objects
     * @param {WorkflowGetDataObjectsRequest} [workflowGetDataObjectsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowDataobjectsGetPost(workflowGetDataObjectsRequest?: WorkflowGetDataObjectsRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowDataobjectsGetPost(workflowGetDataObjectsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get a workflow\'s status and results(if completed & requested)
     * @param {WorkflowGetRequest} [workflowGetRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowGetPost(workflowGetRequest?: WorkflowGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowGetPost(workflowGetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get a workflow\'s status and results(if completed & requested), wait if the workflow is still running
     * @param {WorkflowGetRequest} [workflowGetRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowGetWithWaitPost(workflowGetRequest?: WorkflowGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowGetWithWaitPost(workflowGetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary dump internal info of a workflow
     * @param {WorkflowDumpRequest} [workflowDumpRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowInternalDumpPost(workflowDumpRequest?: WorkflowDumpRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowInternalDumpPost(workflowDumpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary reset a workflow
     * @param {WorkflowResetRequest} [workflowResetRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowResetPost(workflowResetRequest?: WorkflowResetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowResetPost(workflowResetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary execute an RPC of a workflow
     * @param {WorkflowRpcRequest} [workflowRpcRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowRpcPost(workflowRpcRequest?: WorkflowRpcRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowRpcPost(workflowRpcRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary search for workflows by a search attribute query
     * @param {WorkflowSearchRequest} [workflowSearchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowSearchPost(workflowSearchRequest?: WorkflowSearchRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowSearchPost(workflowSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get workflow search attributes
     * @param {WorkflowGetSearchAttributesRequest} [workflowGetSearchAttributesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowSearchattributesGetPost(workflowGetSearchAttributesRequest?: WorkflowGetSearchAttributesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowSearchattributesGetPost(workflowGetSearchAttributesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary signal a workflow
     * @param {WorkflowSignalRequest} [workflowSignalRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowSignalPost(workflowSignalRequest?: WorkflowSignalRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowSignalPost(workflowSignalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary start a workflow
     * @param {WorkflowStartRequest} [workflowStartRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowStartPost(workflowStartRequest?: WorkflowStartRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowStartPost(workflowStartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary for invoking WorkflowState.decide API
     * @param {WorkflowStateDecideRequest} [workflowStateDecideRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowStateDecidePost(workflowStateDecideRequest?: WorkflowStateDecideRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowStateDecidePost(workflowStateDecideRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary for invoking WorkflowState.start API
     * @param {WorkflowStateStartRequest} [workflowStateStartRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowStateStartPost(workflowStateStartRequest?: WorkflowStateStartRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowStateStartPost(workflowStateStartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary stop a workflow
     * @param {WorkflowStopRequest} [workflowStopRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowStopPost(workflowStopRequest?: WorkflowStopRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowStopPost(workflowStopRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary skip the timer of a workflow
     * @param {WorkflowSkipTimerRequest} [workflowSkipTimerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowTimerSkipPost(workflowSkipTimerRequest?: WorkflowSkipTimerRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowTimerSkipPost(workflowSkipTimerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary for invoking workflow RPC API in the worker
     * @param {WorkflowWorkerRpcRequest} [workflowWorkerRpcRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WorkflowWorkerRpcPost(workflowWorkerRpcRequest?: WorkflowWorkerRpcRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1WorkflowWorkerRpcPost(workflowWorkerRpcRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


